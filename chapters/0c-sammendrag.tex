\chapter*{Sammendrag}

Softwaresimulering er en mye brukt metode for å forske på datamaskin arkitekturer. Dessverre er det tregt, spesielt for større parallelle arkitekturer, som GPUer. En detaljert simulering av en GPU kan ta opptil flere dager. \acrshort{fpga}er er konfigurerbare integrerte kretser som kan brukes for å akselerere datamaskin arkitektur simuleringer. De er dermed en middelvei mellom trege softwaresimuleringer og kostbare prototyper.

\Gls{vortex} er en \Gls{riscv} basert GPGPU som kan \acrshort{fpga}-akselereres, og er dermed en god kandidat for forskning innen \acrshort{gpu} arkitekturer. Gjennom min prosjektoppgave~\cite{Aurud_Project}, la jeg til støtte for å generere \acrshort{cpi} stacks for \Gls{vortex}. Det gjorde at jeg identifiserte mulige ytelsesproblemer knyttet til \Gls{vortex} sin frontend og skedulerer. Disse problemene hindrer \Gls{vortex} i å utnytte parallellitet og skjule venting, som reduserer gjennomstrømningen av instruksjoner.

I denne oppgaven, implementerer jeg og evaluerer tre forbedringer til \Gls{vortex} sin mikroarkitektur. Først implementerer jeg \textit{klar skedulering}, som gjør det mulig for \Gls{vortex} å vite hvilke instruksjoner som er klare før de blir utstedt. For det andre, øker jeg gjennomstrømningen av instruksjoner i \Gls{vortex} sin frontend ved å gjøre det mulig å hente instruksjoner uten å blokkere. I tillegg implementerer jeg stansforutsigelse for at \Gls{vortex} skal lære når den må blokkere. Til slutt implementerer jeg en \textit{grådig så eldst} (\acrshort{gto}) skeduleringalgoritme, og sammenlikner dens ytelse med den eksisterende \textit{loose round robin} (\acrshort{lrr}) skedulereren.

I prosjektoppgaven min var genereringen av \acrshort{cpi} stacks koblet til den eksisterende skedulereren. Den samplet bare stansårsaken til instruksjonen valgt av skedulereren. I denne oppgaven utvider jeg denne metoden ved å sample stansårsaken til alle instruksjonene. Dette gir et bedre overblikk over hvorfor \Gls{vortex} står stille. I tillegg utvider jeg \Gls{vortex} sin testbenk ved å overføre 16 testprogrammer fra \Gls{rodinia}, et mye brukt sett med testprogrammer for \acrshort{gpu}er. Denne overføring involverer å endre sentrale komponenter av \Gls{vortex} sitt system for å lese ytelsesdata, og endre testprogrammene sin kildekode for å tilrettelegge for noe manglende OpenCL funksjonalitet.

Implementasjonen av \textit{klar skedulering} fjerner alle sykler hvor instruksjoner er klare, men ingen blir utstedt. For testprogrammer med lav-latens blokkader, som \textit{psort}, er denne endringen nok for å skjule at andre instruksjoner må vente. Dermed fører det til en \acrshort{cpi} reduksjon på $20\%$. \textit{Klar skedulering} har en mye mindre effekt på testprogrammer som er bundet av høy latens. Forbedringene av frontenden øker frontendens båndbredde og reduserer det gjennomsnittlige antallet blokkeringer relatert til frontenden med $71\%$. For \textit{sfilter}, blir alle blokkeringer relatert til frontenden fjernet. Dette er fordi den forbedrede frontenden bare blokkerer for å håndtere flytkontroll, mens \textit{sfilter} ikke har noen flytkontroll instruksjoner. \acrshort{cpi}en blir derimot ikke redusert i samme grad som blokkeringene relatert til frontenden. Ved å kombinere alle endringene, blir den gjennomsnittlige \acrshort{cpi}en redusert med $5.4\%$. Dette er fordi latensen blir for stor til at den kan skjules av den nåværende \Gls{vortex} konfigurasjonen, som er for liten. Flaskehalsen blir dermed flyttet til backenden av \acrshort{gpu}en. Størrelsen på \Gls{vortex} konfigurasjonen er også grunnen til at det ikke er noen forskjell i ytelse for \acrshort{lrr} og \acrshort{gto} skedulererene.