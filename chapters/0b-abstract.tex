\chapter*{Abstract}

While software simulation is a common method for performing architecture research, it is slow for multi-core architectures such as \acrshortpl{gpu}. \acrshort{fpga}-acceleration acts as a middle ground between software simulation and hardware prototypes, by combining fast simulations with rapid turnaround time when changing configurations. \Gls{vortex} is a \Gls{riscv} based \acrshort{gpgpu} capable of being \acrshort{fpga}-accelerated, thus being a good candidate for architecture research. Previous research found potential performance bottlenecks in Vortex' frontend and schedulers. This inhibited vortex in exploiting \acrshort{simd} and \acrshort{mlp}, reducing its throughput and making it latency bound.

In this thesis I implement \textit{no-stall-scheduling} and \textit{stall-prediction} allowing vortex to schedule consecutive warps without stalling the frontend, and improve its icache-stage to increase throughput of the fetch stage. Additionally I improve Vortex' schedulers to detect ready warps, removing unnecessary stalls. I also examine the impact of switching from a \textit{loose-round-robin}(\acrshort{lrr}) to a \textit{greedy-then-oldest}(\acrshort{gto}) scheduling algorithm.

To improve the insight into Vortex' performance, I expand upon my previous method for generating \textit{cycle-stacks for Vortex}(\acrshort{csv}), giving greater insight into what is causing Vortex to stall. Lastly I broaden Vortex' lacking benchmark suite by implementing benchmarks from Rodinia, a commonly used set of \acrshort{gpu} benchmarks. 

The frontend changes heavily reduce the number of stalls caused by \Gls{vortex}' mechanisms to handle control flow. Together with the new schedulers it allows the issue stage to utilize its functional units to a greater degree. The changes give an average reduction in \acrshort{cpi} of --\% over the baseline, with \textit{psort}, \textit{sgemm} and \textit{Needleman-Wunsch} seeing a 20\% reduction in \acrshort{cpi}. However, some benchmarks see a slight increase or no change to their \acrshort{cpi}. This is due to a lack of memory bandwidth and \acrshort{mlp}, which can be solved by increasing the number of warps per \acrshort{sm}, and use a memory system more suitable for \acrshortpl{gpu}. I observe little to effect of using \acrshort{gto} over \acrshort{lrr}, which is likely due to weaknesses in my implementation. 